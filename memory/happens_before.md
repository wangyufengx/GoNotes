# 先行发生

在单个 goroutine 中，读取和写入必须按照程序指定的顺序执行。也就是说，只有当重新排序不会改变语言规范定义的 goroutine 中的行为时，编译器和处理器才可以重新排序在单个 goroutine 中执行的读取和写入。由于这种重新排序，一个goroutine观察到的执行顺序可能与另一个goroutine观察到的执行顺序不同。例如，如果一个 goroutine 执行 `a = 1; b = 2;`，另一个可能会在 `a` 的更新值之前观察到 `b` 的更新值。

为了指定读和写的要求，我们定义了在Go程序中内存操作执行的部分顺序。如果事件 e1 发生在事件 e2 之前，那么我们说 e2 发生在 e1 之后。另外，如果 e1 没有在 e2 之前发生，也没有在 e2 之后发生，那么我们说 e1 和 e2 同时发生。

在单个 goroutine 中，happens-before 顺序是程序表达的顺序。

如果以下两项都成立，则允许变量 `v` 的读取 *r* 观察写入 *w* 到 `v`：

1. *r* 不会在 *w* 之前发生。
2. 没有其他写 *w'* 到 `v` 发生在 *w* 之后但在 *r* 之前。

为了保证对变量 `v` 的读取 *r* 观察到对 `v` 的特定写入 *w*，请确保 *w* 是唯一允许观察的写入 *r*。 也就是说，*r* *保证*观察到 *w* 如果以下两个都成立：

1. *w* 发生在 *r* 之前。
2. 对共享变量 `v` 的任何其他写入发生在 *w* 之前或 *r* 之后。

这对条件比第一对强； 它要求没有其他写入与 *w* 或 *r* 同时发生。

在单个 goroutine 中，没有并发，因此两个定义是等价的：读取 *r* 观察最近写入 *w* 到 `v` 的值。 当多个 goroutine 访问共享变量 `v` 时，它们必须使用同步事件来建立happens-before 条件，以确保读取观察到所需的写入。

使用 v 类型的零值初始化变量 v 的行为类似于内存模型中的写入。

对大于单个机器码的值的读取和写入表现为未指定顺序的多个机器码大小的操作。
